### 13.2    名字查找

在 C++ 中，名字查找有很多小细节，但我们将只关注一些主要概念。细节是必要的，以确保仅（1）正常的情况能被直观地处理，以及（2）标准以某些方式涵盖了病态的情况。

有限定名在由限定构造所指定的作用域内查找。如果作用域是类，那么基类也可能被查找。但是，当查找有限定名时，不考虑外围作用域。下面的例子解释了这一基本原则：

```c++
int x;

class B {
  public:
    int i;
};

class D : public B {
};

void f(D* pd)
{
    pd->i = 3;	// 找到了 B::i
    D::x = 2;	// 错误：找不到外围作用域中的 ::x
}
```

相比之下，无限定名通常在更多连续的外围作用域中查找（尽管在成员函数定义中，在类和基类的作用域中的查找要先于其它任何外围作用域的查找）。这称作*普通查找*（ordinary lookup）。下面的基本示例展示了普通查找的主要思想：

```c++
extern int count;				// #1

int lookup_example(int count)	// #2
{
    if (count < 0) {
        int count = 1;			// #3
        lookup_example(count);	// 无限定的 count 指代 #3
    }
    return count + ::count;		// 第一个 count（无限定）指代 #2
    							// 第二个 count（有限定）指代 #1
}
```

无限定名的查找的最新改变是，除了普通查找外，它们有时还可能进行*实参依赖查找*（argument-dependent lookup，ADL）。[^2] 在继续讨论 ADL 的细节前，让我们用经常使用的 `max()` 模板来引入这一机制：

[^2]:在 C++98/C++03 中，这也叫做 *Koenig 查找*（或*扩展的 Koenig 查找*），Andrew Koenig 首先提出了这种机制的变体。

```c++
template<typename T>
T max (T a, T b)
{
    return  b < a ? a : b;
}
```

假设我们现在要将该模板应用到另一个类型上，该类型定义在其它命名空间中：

```c++
namespace BigMath {
    class BigNumber {
        ...
    };
    bool operator < (BigNumber const&, BigNumber const&);
    ...
}

using BigMath::BigNumber;

void g (BigNumber const& a, BigNumber const& b)
{
    ...
    BigNumber x = ::max(a,b);
    ...
}
```

这里的问题是，`max()` 模板不知道 `BigMath` 命名空间的存在，而普通查找找不到适用于 `BigNumber` 类型的值的运算符 `<`。如果没有一些特殊规则，这将极大地减少在存在 C++ 命名空间时模板的适用性。ADL 是 C++ 对这些 “特殊规则” 的回答。

#### 13.2.1    实参依赖查找

ADL 主要适用于无限定名，这些无限定名看起来像在函数调用或运算符调用中非成员函数的名字。如果普通查找找到了下面的内容，就不会发生 ADL：

+ 成员函数名，
+ 变量名，
+ 类型名，或
+ 块作用域函数声明的名字。

如果被调用的函数名包围在括号中，也会阻止 ADL。

否则， 如果名字后面跟随了用括号包围的实参表达式列表，ADL 就在和调用实参的类型 “关联” 的命名空间和类中查找名字。这些*关联命名空间*和*关联类*的精确定义在后面给出，但直观地看，可以认为它们就是与给定类型直接关联的所有命名空间和类。例如，如果类型是类 `X` 的指针，那么关联的类和命名空间将包含 `X` 以及任何 `X` 所属的命名空间或类。

给定类型的*关联命名空间*和*关联类*集合的精确定义由下面的规则确定：

+ 对于内置类型，就是空集合。
+ 对于指针和数组类型，关联命名空间和关联类的集合就是底层元素类型的关联集合。
+ 对于枚举类型，关联命名空间是该枚举声明所在的命名空间。
+ 对于类成员，外围类是关联类。
+ 对于类类型（包括联合体类型），关联类集合就是该类型本身、外围类，以及所有直接和间接基类。关联命名空间集合由关联类声明所在的命名空间组成。如果该类是类模板实例，那么模板类型实参的类型以及模板模板实参声明所在的类和命名空间都将被包含。
+ 对于函数类型，关联命名空间和关联类集合包括所有和形参类型关联的命名空间和类，以及与返回类型关联的命名空间和类。
+ 对于指向类 X 的成员指针类型，关联命名空间和关联类的集合包括和 `X` 关联的类和命名空间，以及和成员的类型关联的类和命名空间。（如果是指向成员函数的指针类型，那么也会添加形参和返回类型的关联集合。）

然后 ADL 会在所有关联命名空间中查找名字，如同依次用这些命名空间中的每一个限定名字一般查找，只不过会忽略 using 指令。下面的例子解释了这一点：

*details/adl.cpp*

```c++
#include <iostream>

namespace X {
    template<typename T> void f(T);
}

namespace N {
    using namespace X;
    enum E { e1 };
    void f(E) {
        std::cout << "N::f(N::E) called\n";
    }
}

void f(int)
{
    std::cout << "::f(int) called\n";
}

int main()
{
    ::f(N::e1);		// 有限定的函数名：不执行 ADL
    f(N::e1);		// 普通查找找到了 ::f()，ADL 找到了 N::f()，选择后者
}
```

注意在这个例子中，执行 ADL 时命名空间 `N` 中的 using 指令被忽略。因此 `X::f()` 不是 `main()` 中调用的候选函数。

#### 13.2.2    友元声明的实参依赖查找

友元函数声明可以是要指明友元的函数的首个声明。如果是这种情况，就假定函数声明在该友元声明所在类的最内层外围命名空间作用域（可能是全局作用域）。然而，这样的友元声明在该作用域中不能直接可见。考虑下面的例子：

```c++
template<typename T>
class C {
    ...
    friend void f();
    friend void f(C<T> const&);
    ...
};

void g (C<int>* p)
{
    f();	// f() 在这里可见吗？
    f(*p);	// f(C<int> const&) 在这里可见吗？
}
```

如果友元声明在外围作用域中可见，那么实例化类模板可以使普通函数的声明可见。这将导致令人惊讶的行为：调用 `f()` 将导致编译错误，除非类 `C` 的实例化在程序中更早的位置出现！

另一方面，只在友元声明中声明（和定义）函数可能是很有用的（关于依赖于这一行为的技术，见原书 497 页 21.2.1 节）。当友元函数所属的类是 ADL 所考虑的关联类时，这样的函数能被找到。

再次考虑最后的例子。调用 `f()` 没有关联类或关联命名空间，因为没有实参：在我们的例子中这是一个无效的调用。然而，调用 `f(*p)` 确实有关联类 `C<int>`（因为这是 `*p` 的类型），而且全局命名空间也会被关联（因为这是 `*p` 的类型声明所在的命名空间）。因此，如果在这次调用前类 `C<int>` 实际上已经完全实例化，就能找到第二个友元函数声明。为了确保这一点，假设涉及在关联类中查找友元的调用实际上会导致关联类被实例化（如果它还没被实例化）。[^3]

[^3]:尽管 C++ 标准的编写者很清楚地表示这一点，但标准中并没有明确说明。

实施实参依赖查找以找到友元声明和定义的能力有时被称为*友元名注入*（friend name injection）。然而，这一术语有些误导，因为它是前标准 C++ 的特性，它实际上确实将友元声明的名字 “注入” 到外围作用域，使它们对普通名字查找可见。在我们上面的例子中，这意味着两个调用都将是良构的。本章后记进一步详细说明了友元名注入的历史。

#### 13.2.3    注入类名

类名被注入到类本身的作用域中，因此在该作用域中可以作为无限定名访问。（但是它不能作为有限定名访问，因为这是用于表示构造函数的符号。）例如：

*details/inject.cpp*

```c++
#include <iostream>

int C;

class C {
  private:
    int i[2];
  public:
    static int f() {
        return sizeof(C);
    }
};

int f()
{
    return sizeof(C);
}

int main()
{
    std::cout << "C::f() = " << C::f() << ','
              << " ::f() = " << ::f() << '\n';
}
```

成员函数 `C::f()` 返回类型 `C` 的大小，而函数 `::f()` 返回变量 `C` 的大小（或者说，`int` 对象的大小）。[^-1]

[^-1]:译者注：对于 `::f()`，变量 `C` 和类 `C` 处于相同的作用域，根据[标准](https://eel.is/c++draft/basic.lookup#general-note-4)，A type (but not a typedef-name or template) is therefore hidden by any other entity in its scope.（类型会被作用域中的其它实体隐藏。）

类模板也有注入类名。然而，它们比普通的注入类名更奇怪：它们后面可以跟随模板实参（在这种情况下它们是注入类*模板*名），而如果它们后面没有跟随模板实参，那么当所在的上下文期待类型时，就代表用自己的模板形参作为实参（对于部分特化，则作为特化所用的实参）得到的类；当所在的上下文期待模板时，就代表模板本身。这解释了下面的情况：

```c++
template<template<typename> class TT> class X {
};

template<typename T> class C {
    C* a;		// 正确：和 "C<T>* a;" 相同
    C<void>& b;	// 正确
    X<C> c;		// 正确：不带有模板实参列表的 C 表示模板 C
    X<::C> d;	// 正确：::C 不是注入类名，因此永远表示该模板
}
```

注意无限定名是如何指代注入名的，以及如果它后面没有跟随模板实参列表，何时不会被认为是模板的名字。作为补偿，我们可以通过使用文件作用域限定符 `::` 来强制找到模板的名字。

变参模板的注入类名有一个额外的问题：如果用变参模板的模板形参作为模板实参直接形成注入类名，那么注入类名中将包含未展开的模板形参包（关于包展开的细节，见原书 201 页 12.4.1 节）。因此，当为变参模板形成注入类名时，对应于模板形参包的模板实参将是包展开，其模式就是该模板形参包：

```c++
template<int I, typename... T> class V {
    V* a;			// 正确：和 "V<I, T...>* a;" 相同
    V<0, void> b;	// 正确
}
```

#### 13.2.4    当前实例化

类或类模板的注入类名实际上是正在被定义的类型的别名。对于非模板类，这一属性更明显，因为该类本身是具有该名字并在该作用域中的唯一类型。然而，在类模板内或类模板的嵌套类内，每个模板实例都产生不同的类型。这一属性在这样的上下文中特别有趣，因为这意味着注入类名指代类模板的相同实例，而不是该类模板的其它特化（这同样适用于类模板的嵌套类）。

在类模板内，任何外围类或类模板的注入类名或任何等价于这些注入类名的类型（包括替换类型别名声明后的结果），称为指代*当前实例化*（current instantiation）。依赖于模板形参但不指代当前实例化的类型（即*待决类型*，dependent type）称为指代*未知特化*（unknown specialization），它可以从相同的类模板或一些完全不同的类模板实例化。下面的例子解释了差异：

```c++
template<typename T> class Node {
  using Type = T;
  Node* next;			// Node 指代当前实例化
  Node<Type>* previous;	// Node<Type> 指代当前实例化
  Node<T*>* parent;		// Node<T*> 指代未知特化
};
```

在嵌套类和嵌套类模板存在的情况下，判断类型是否指代当前实例化可能令人困惑。外围类和类模板的注入类名（或者等价于它们的类型）确实指代当前实例化，而其它嵌套类或类模板的名字不指代：

```c++
template<typename T> class C {
  using Type = T;
    
  struct I {
    C* c;				// C 指代当前实例化
    C<Type>* c2;		// C<Type> 指代当前实例化
    I* i;				// I 指代当前实例化
  };
    
  struct J {
    C* c;				// C 指代当前实例化
    C<Type>* c2;		// C<Type> 指代当前实例化
    I* i;				// I 指代未知特化，
      					// 因为 I 不包围 J
    J* j;				// J 指代当前实例化
  };
};
```

当类型指代当前实例化时，被实例化的类的内容保证是来自当前正被定义的类模板或嵌套类的。这对于解析模板时的名字查找有影响（这是我们下一节的主题），但它也会导致另一种更像游戏的方式来确定在类模板定义中的类型 `X` 指代当前实例化还是未知特化：如果另一个程序员能编写显式特化（细节在第 16 章描述）使得 `X` 指代该特化，那么 `X` 指代未知特化。例如，考虑上个例子的上下文中类型 `C<int>::J` 的实例化：我们知道用于实例化具体类型的 `C<T>::J` 的定义（因为那就是我们正实例化的类型）。此外，因为显式特化不能仅特化模板或模板的成员而不同时特化所有的外围模板或成员，因此 `C<int>` 将从外围类定义实例化。因此，在 `J` 中对 `J` 和 `C<int>` 的引用（其中 `Type` 是 `int`）指代当前实例化。另一方面，其他人可以像下面这样为 `C<int>::I` 编写显式特化：

```c++
template<> struct C<int>::I {
  // 特化的定义
};
```

这里，`C<int>::I` 的特化提供了定义，它与从 `C<T>::J` 的定义中能见到的 `C<T>::I` 的定义完全不同，因此 `C<T>::J` 的定义中的 `I` 指代未知特化。