## 第 13 章    模板中的名字

名字是大多数编程语言中的基本概念。程序员使用它们引用前面构造的实体。当 C++ 编译器遇到名字时，就必须 “查找” 它来确定被引用的实体。从实现的角度看，C++ 在这方面是一种困难的语言。考虑 C++ 语句 `x*y;`。如果 `x` 和 `y` 是变量名，那么这条语句执行乘法，但是如果 `x` 是一种类型的名字，那么这条语句将 `y` 声明为指向 `x` 类型的实体的指针。

这个小例子表明 C++（像 C 那样）是一种*上下文敏感的语言*（context-sensitive language）：如果不知道更广泛的上下文，一个构造有时就不能被理解。这和模板有什么关系呢？模板是必须处理多个更广泛的上下文的构造：（1）模板出现的上下文，（2）模板实例化的上下文，以及（3）与用于实例化模板的模板实参相关联的上下文。因此，在 C++ 中必须非常小心地处理 “名字”，这并不奇怪。

### 13.1    名字的分类

C++ 用多种方式对名字分类——事实上，有大量的分类方式。为了帮助处理大量的术语，我们提供了表 13.1，用于描述这些分类。幸运的是，通过熟悉两个主要的命名概念，你可以深入理解大多数 C++ 模板问题：

1. 如果使用作用域解析运算符（`::`）或成员访问运算符（`.` 或 `->`）显式指出了名字所属的作用域，那么名字就是*有限定的名字*（qualified name）。例如，`this->count` 是有限定的名字，而 `count` 不是（即使普通的 `count` 可能实际上指代类成员）。
2. 如果名字以某种方式依赖于模板形参，那么它就是*待决名*（dependent name）。例如，如果 `T` 是模板形参，那么 `std::vector<T>::iterator` 通常是待决名，但是如果 `T` 是已知类型的别名（比如 `T` 来自于 `using T = int`），那么它就是非待决名。

| 分类                                    | 解释和注意事项                                               |
| --------------------------------------- | ------------------------------------------------------------ |
| 标识符（identifier）                    | 仅由连续的字母、下划线（`_`）和数字组成的名字。不能以数字开头，而且一些标识符为实现保留：你不能在你的程序中引入它们（经验法则是，避免前导的下划线和任何位置的双下划线）。“字母” 的概念是广义的，且包括特殊的*通用字符名*（universal character name，UCN），它编码了非字母语言的字形。 |
| 运算符函数标识（operator-function-id）  | 关键字 `operator` 后随运算符的符号——例如，`operator new` 和 `operator []`。 |
| 转换函数标识（conversion-function-id）  | 用于表示用户定义的隐式转换运算符——例如，`operator int&`，它也能写作 `operator int bitand`。 |
| 字面值运算符标识（literal-operator-id） | 用于表示用户定义字面值运算符——例如，`operator ""_km`，当编写例如 `100_km` 的字面值时，将使用它（在 C++11 中引入）。 |
| 模板标识（template-id）                 | 模板的名字后随包围在尖括号中的模板实参；例如，`List<T, int, 0>`。模板标识也可以是后随包围在尖括号中的模板实参的运算符函数标识或字面值运算符标识；例如，`operator+<X<int>>`。 |
| 无限定标识（unqualified-id）            | 标识符的一般形式。它可以是上面（标识符、运算符函数标识、转换函数标识、字面值运算符标识或模板标识）中的任何一个，或者是 “析构函数名”（即像 `~Data` 或 `~List<T, T, N>` 这样的表示）。 |
| 有限定标识（qualified-id）              | 被类、枚举或命名空间的名字限定的无限定标识，或者仅仅带有全局作用域解析运算符。注意，这样的名字本身也可以被限定。例子是 `::X`、`S::x`、`Array<T>::y` 和 `::N::A<T>::z`。 |
| 有限定名（qualified name）              | 这一术语没有在标准中定义，但我们用它指代被*有限定查找*（qualified lookup）的名字。具体而言，这是显式成员访问运算符（`.` 或 `->`）之后的有限定标识或无限定标识。例子是 `S::x`、`this->f` 和 `p->A::m`。然而，在隐式等价于 `this->class_mem` 的上下文中单独的 `class_mem` 不是有限定名：成员访问必须是显式的。 |
| 无限定名（unqualified name）            | 不属于有限定名的无限定标识。这不是标准术语，而是对应于这样的名字：它们要经过标准称为的*无限定查找*（unqualified lookup）。 |
| 名字（name）                            | 有限定名或无限定名。                                         |
| 待决名（dependent name）                | 以某种方式依赖于模板形参的名字。典型地，显式包含模板形参的有限定名或无限定名是待决的。进一步，对于被成员访问运算符（`.` 或 `->`）限定的有限定名，如果成员访问运算符左侧的表达式的类型是*类型待决的*（type-dependent），那该有限定名是待决的。类型待决的概念在（原书）233 页 13.3.6 节讨论。特别的，当 `this->b` 出现在模板中时，其中的 `b` 通常是待决名。最后，实参依赖查找（在原书 217 页 13.2 节描述）中的名字，例如形式为 `ident(x, y)` 的调用中的 `ident`，或表达式 `x + y` 中的 `x`，当且仅当任意实参表达式是类型待决时，该名字是待决名。 |
| 非待决名                                | 根据上面的描述不属于待决名的名字。                           |

这些术语有时用于描述 C++ 问题，通读表格并熟悉这些术语是很有用的，但不需要记住每个术语的精确含义。如果需要，可以在索引中轻松地找到它们。