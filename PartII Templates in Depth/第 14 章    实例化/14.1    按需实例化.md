## 第 14 章    实例化

模板实例化是从泛型模板定义生成类型、函数和变量的过程。[^1] C++ 模板的实例化概念是基础的，但又有些复杂的。导致这种复杂性的本质原因之一是由模板生成的实体的定义不再局限于源代码中的单个位置。模板的位置、使用模板的位置以及模板实参定义的位置都对该实体的含义有影响。

[^1]:术语*实例化*（instantiation）有时也用于指代从类型创建对象。然而，在本书中，它永远指代*模板*实例化。

在本章中我们将解释如何组织源代码以正确使用模板。此外，我们调查了最流行的 C++ 编译器用于处理模板实例化的不同方法。尽管所有这些方法在语义上都应该等价，但理解编译器实例化策略的基本原则是有用的。当构建真实世界的软件时，每种机制都会有自己的特别之处，并且它们都会影响标准 C++ 最终的规范。

### 14.1    按需实例化

当 C++ 编译器遇到对模板特化的使用时，它通过将模板形参替换为需要的实参来创建特化。[^2] 这是自动完成的，并且不需要客户端代码（或模板定义）的指示。这种按需实例化特性使得 C++ 模板和其它早期的编译型语言（如 Ada 或 Eiffel，这些语言中的一部分要求显式实例化指令，而其它语言使用运行时派发机制来完全避免实例化过程）中的类似设施区分开。这有时也叫做*隐式*（implicit）或*自动*（automatic）实例化。

[^2]:术语*特化*（specialization）用于模板的特定实例的实体的一般意义（见第 10 章）。它不指代第 16 章中描述的*显式特化*（explicit specialization）机制。

按需实例化隐含表示编译器通常需要在使用点访问模板和其部分成员的完整定义（换句话说，不仅仅是声明）。考虑下面的简短的源代码文件：

```c++
template<typename T> class C;   // #1 仅为声明

C<int>* p = 0;                  // #2 正确：不需要 C<int> 的定义

template<typename T>
class C {
  public:
    void f();                   // #3 成员声明
};                              // #4 类模板定义完成

void g (C<int>& c)              // #5 仅使用类模板声明
{
    c.f();                      // #6 使用类模板定义；
}                               //    将在当前翻译单元中
                                //    需要 C::f() 的定义

template<typename T>
void C<T>::f()                  // #6 需要的定义
{
}
```

在该源代码的位置 *#1*，只有该模板的声明（不是定义）是可用的（这样的声明有时叫做*前置声明*（forward declaration））。和普通类的情况一致，声明到该类型的指针或引用不需要该类模板的定义可见，就像位置 *#2* 所做的那样。例如，函数 `g()` 的形参的类型不需要模板 `C` 的完整定义。然而，只要某个组件需要知道模板特化的大小，或者它访问了这样的特化的成员，那么完整的类模板定义就需要可见。这解释了为什么在源代码中的位置 *#6* 类模板定义必须可见；否则，编译器不能验证该成员存在且可访问（不是私有的或受保护的）。此外，成员函数的定义也是需要的，因为位置 *#6* 的调用要求 `C<int>::f()` 存在。

这里是另一个需要前面的类模板的实例化的表达式，因为需要 `C<void>` 的大小：

```c++
C<void>* p = new C<void>;
```

在本例中，需要实例化，以便编译器能确定 `C<void>` 的大小，`new` 表达式需要该大小以确定分配多少存储。你可能注意到对于这一特定的模板，替换 `T` 的实参 `X` 的类型将不影响该模板的大小，因为在任何情况下，`C<X>` 都是空类。然而，不要求编译器通过分析模板定义来避免实例化（并且实践中所有编译器都执行实例化）。此外，本例中也需要实例化来确定 `C<void>` 是否拥有可访问的默认构造函数，并确保 `C<void>` 没有声明成员运算符 `new` 或 `delete`。

访问类模板成员的需要在源代码中并不总是非常明确。例如，C++ 重载决议需要查看候选函数形参的类类型：

```c++
template<typename T>
class C {
  public:
    C(int);           // 可以用单个参数调用的构造函数
};                    //  可以用于隐式转换

void candidate(C<double>);  // #1
void candidate(int) { }     // #2

int main()
{
    candidate(42);  // 前面的两个函数声明都可以被调用
}
```

调用 `candidate(42)` 将决议为位置 *#2* 处的重载声明。然而，位置 *#1* 处的声明也会被实例化以检查它是否是该调用的可行候选函数（在本例中是因为单个实参的构造函数可以将 `42` 隐式转换为类型 `C<double>` 的右值）。注意如果编译器能在没有实例化的情况下决议该调用，则允许（但不是要求）编译器执行该实例化（正如本例中的情况，因为不会在精确匹配时选择隐式转换）。也要注意 `C<double>` 的实例化可能触发错误，这可能令人惊讶。