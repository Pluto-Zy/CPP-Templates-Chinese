### A.2    声明和定义

术语*声明*（declaration）和*定义*（definition）在一般的 “程序员交谈” 中经常互换使用。然而，在 ODR 的上下文中，这些单词的精确含义很重要。[^1]

[^1]:我们也认为，在交换关于 C 和 C++ 的想法时，仔细使用这些术语是一个好习惯。我们在整本书中都是这样做的。

声明是一个 C++ 结构，它（通常）[^2]在你的程序中引入或重新引入了一个名字。声明也可以是一个定义，取决于它引入了怎样的实体，以及是怎样引入的：

[^2]:一些结构（如 `static_assert`）不会引入任何名字，但在语法上视为声明。

+ **命名空间和命名空间别名：**命名空间和它们的别名的声明永远是定义，尽管在这样的上下文中不常见到术语*定义*，因为命名空间的成员列表可以在随后 “扩展”（这与类和枚举类型不同）。
+ **类、类模板、函数、函数模板、成员函数和成员函数模板：**当且仅当声明包含与名字关联的花括号包围的主体时，声明才是定义。这一规则包括联合体、运算符、成员运算符、静态成员函数、构造函数和析构函数，以及上述内容的模板版本的显式特化（即，任何类类和类函数的实体）。
+ **枚举：**当且仅当它包含由花括号包围的枚举项列表时，声明是定义。
+ **局部变量和非静态数据成员：**这些实体总是可以视为定义，尽管区别很小。注意在函数定义中函数形参的声明本身就是定义，因为它表示局部变量，但是在不属于定义的函数声明中的函数形参不是定义。
+ **全局变量：**如果声明没有直接前置关键字 `extern`，或者它带有初始化器，那么全局变量的声明也是该变量的定义。否则，它不是定义。
+ **静态数据成员**：当且仅当声明出现在其所属的类或类模板之外，或者它在类或类模板内声明为 `inline` 或 `constexpr` 时，声明是定义。
+ **显式和部分特化**：如果 `template<>` 或 `template<...>` 之后的声明本身就是定义，那么整个声明就是定义，例外是静态数据成员或静态数据成员模板的显式特化只有在包含初始化器时才是定义。

其它声明不是定义。这包括类型别名（`typedef` 或 `using`）、using 声明、using 指令、模板形参声明、显式实例化指令、`static_assert` 声明，等等。

