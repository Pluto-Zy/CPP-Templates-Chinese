### A.3    单一定义规则的细节

正如我们在本附录的介绍中提到的那样，实际的 ODR 由很多细节。我们将按照规则的约束范围组织它们。

#### A.3.1    程序中的单一定义约束

下面的项目在每个程序中至多一个定义：

+ 非内联函数和非内联成员函数（包括函数模板的全特化）
+ 非内联变量（本质上是在命名空间作用域或全局作用域中声明的、且不带有 `static` 说明符的变量）
+ 非内联静态数据成员

例如，由下面的两个翻译单元组成的 C++ 程序的不合法的：

```c++
// ==== 翻译单元 1：
int counter;

// ==== 翻译单元 2：
int counter;		// 错误：定义了两次（违反 ODR）
```

这一规则不会应用在带有*内部连接*（internal linkage）的实体上（本质上是声明在全局作用域或命名空间作用域中的带有 `static` 说明符的实体），因为即使两个这样的实体有相同的名字，它们也会被认为是不同的。同样，声明于无名命名空间中的实体如果出现在不同的翻译单元中，则它们被认为是不同的；在 C++11 和更高的版本中，这样的实体也默认带有内部连接，但是早于 C++11 时，它们默认带有外部连接。例如，下面的两个翻译单元可以被结合为一个有效的 C++ 程序：

```c++
// ==== 翻译单元 1：
static int counter = 2;		// 与其它翻译单元无关

namespace {
    void unique()			// 与其它翻译单元无关
    {
    }
}

// ==== 翻译单元 2：
static int counter = 0;		// 与其它翻译单元无关

namespace {
    void unique()			// 与其它翻译单元无关
    {
        ++counter;
    }
}

int main()
{
    unique();
}
```

此外，如果在 constexpr if 语句（一个只在 C++17 中可用的特性；见原书 263 页 14.6 节）的被丢弃分支以外的上下文中*使用*上面提到的项目，程序中就必须*有且仅有*一个对应项目。此上下文中的术语*使用*有精确的含义。它表示在程序中的某处存在对实体的某种引用，导致直接代码生成需要该实体。[^3]该引用可以是对变量值的访问、对函数的调用，或者这样实体的地址。这个引用在代码中显式出现，也可以是隐式的。例如，当构造函数抛出异常需要清理未使用（但已分配）的内存时，`new` 表达式可能创建对关联的 `delete` 运算符的隐式调用以处理该情况。另一个例子和复制构造函数有关，即使它们最终被优化掉，也必须被定义（除非语言要求它们被优化掉，这在 C++17 中频繁出现）。虚函数也会（由允许虚函数调用的内部结构）隐式使用，除非它们是纯虚函数。还存在一些其它类型的隐式使用，但为了简洁起见我们省略了它们。

[^3]:许多优化技术可能使该需求被移除，但是语言不会假定这种优化发生。

一些引用*不*构成前面提到的使用的含义：那些出现在*不求值操作数*（unevaluated operand）（例如，`sizeof` 或 `decltype` 运算符的操作数）中的引用。`typeid` 运算符（见原书 138 页 9.1.1 节）的操作数只在一些情况下才*不求值*（unevaluate）。具体来说，如果引用作为了 `typeid` 运算符的一部分出现，那么除非 `typeid` 运算符的实参最终指定了一个多态对象（带有（可能被继承的）虚函数的对象），否则就不属于前面提到的使用。例如，考虑下面的单个文件的程序：

```c++
#include <typeinfo>

class Decider {
#if defined(DYNAMIC)
    virtual ~Decider() {
    }
#endif
};

extern Decider d;

int main()
{
    char const* name = typeid(d).name();
    return (int)sizeof(d);
}
```

当且仅当预处理符号 `DYNAMIC` 未被定义时，该程序有效。实际上，变量 `d` 未被定义，但是在 `sizeof(d)` 中对 `d` 的引用没有构成一个使用，且只有在 `d` 是多态类型的对象时，在 `typeid(d)` 中的引用才是一个使用（因为，通常在运行前并不总是能够确定多态 `typeid` 运算的结果）。

根据 C++ 标准，这一节描述的约束不要求 C++ 实现进行诊断。实际上，这些通常被链接器报告为重复或缺失定义错误。

#### A.3.2    翻译单元中的单一定义约束

任何实体都不能在一个翻译单元中多次定义。所以，下面的例子在 C++ 中不合法：

```c++
inline void f() {}
inline void f() {}  // 错误：重复定义
```

这是在头文件中使用*卫士*（guards）包围代码的主要原因之一：

```c++
// ==== guarddemo.hpp:
#ifndef GUARDDEMO_HPP
#define GUARDDEMO_HPP
...
#endif  // GUARDDEMO_HPP
```

这样的卫士确保了一个头文件被第二次 `#include` 时，它的内容会被丢弃，从而避免了它可能包含的类、内联实体、模板等内容的重复定义。

ODR 也限定了在某些情况下必须定义某些实体。可以是类类型、内联函数和内联变量。在下面的几段中，我们回顾了详细的规则。

类类型 `X`（包括 `struct` 和 `union`）*必须*在翻译单元中的以下任何类型的使用之前被定义：

+ 创建类型为 `X` 的对象（例如，使用变量声明，或通过 `new` 表达式）。这一创建可以是间接的，例如，创建一个对象，其本身包含类型为 `X` 的对象。
+ 声明类型为 `X` 的数据成员。
+ 对类型为 `X` 的对象应用 `sizeof` 或 `typeid` 运算符。
+ 显式或隐式访问类型 `X` 的成员。
+ 使用任意类型的转换将表达式从类型 `X` 转换，或转换到类型 `X`，或者使用隐式转换、`static_cast`、`dynamic_cast` 将表达式从到 `X` 的指针或引用类型（除了 `void*`）转换，或转换为 `X` 的指针或引用类型（除了 `void*`）。
+ 将一个值赋值给 `X` 类型的对象。
+ 定义或调用一个实参或返回值类型为 `X` 的函数。但是仅仅声明这样的函数不要求该类型被定义。

这一针对类型的规则同样适用于从类模板生成的类型 `X`，这意味着在这样的类型 `X` 必须被定义的情况下，对应的模板也必须被定义。这些情况会创建*实例化点*（points of instantiation 或 POI）（见原书 250 页 14.3.2 节）。

内联函数必须在使用它们（调用或获取它们的地址）的每个翻译单元中定义。但是，与类类型不同，它们的定义可以在使用点的后面：

```c++
inline int notSoFast();

int main()
{
    notSoFast();
}

inline int notSoFast()
{
}
```

尽管这在 C++ 中合法，一些基于旧的技术的编译器实际上并不会 “内联” 对具有未见过的主体的函数的调用；因此可能无法达到预期的效果。

就像类模板一样，使用从参数化的函数声明（函数模板或成员函数模板，或者类模板的成员函数）生成的函数会创建实例化点。然而，与类模板不同的是，对应的定义可以出现在实例化点之后。

这一节中介绍的 ODR 的各个方面通常很容易被 C++ 编译器验证；因此，C++ 标准要求编译器在违反这些规则之一时给出某种诊断。一个例外是缺失参数化的函数的定义。这样的情况通常不能被诊断出来。

#### A.3.3    跨翻译单元的等价约束

在多个翻译单元中定义某种类型的实体的能力带来了产生新错误的可能性：不匹配的多个定义。不幸的是，传统的编译器技术一次处理一个翻译单元，很难检测到这种错误。因此，C++ 标准不*要求*检测或诊断多个定义的不同（当然，它确实*允许*这么做）。但是，如果违反了这样的跨翻译单元约束，C++ 标准会将其限定为将导致*未定义行为*（undefined behavior），这意味着可能产生任何合理或不合理的结果。此类非诊断错误通常会导致程序崩溃或错误的结果，但原则上它们还可能导致其它的更直接的损坏（如文件损坏）。[^4]

[^4]:gcc 编译器的第 1 个版本实际上会在类似于这样的情况发生时，开玩笑地启动 Rogue 游戏来实现这一点。

跨翻译单元约束规定，当一个实体在两个不同的地方定义时，这两个地方必须由完全相同的标记序列（关键字、运算符、标识符等在预处理后留下的标记）组成。此外，这些标记必须在它们各自的上下文中具有相同的含义（例如，标识符需要引用相同的变量）。

考虑下面的例子：

```c++
// ==== 翻译单元 1：
static int counter = 0;
inline void increaseCounter()
{
    ++counter;
}

int main()
{
}

// ==== 翻译单元 2：
static int counter = 0;
inline void increaseCounter()
{
    ++counter;
}
```

这个例子是错误的，因为即使内联函数 `increaseCounter()` 的标记序列看上去在两个翻译单元中都相同，它们包含的标记 `counter` 还是引用了两个不同的实体。事实上，因为这两个叫做 `counter` 的变量具有内部连接（`static` 说明符），它们是无关的（即使有相同的名字）。注意，即使这两个内联函数都没有被使用，这也是错误。

将可以在多个翻译单元中被定义的实体的定义放置在头文件中，并在任何时候需要该定义时 `#include`，就可以确保标记序列在几乎任何时候都是相同的。[^5]有了这种方法，两个相同的标记指代不同实体的情况将变得相当罕见，但是当这个问题确实发生时，由此产生的错误通常是神秘且难以追踪的。

[^5]:有时，条件编译指令在不同的翻译单元中的求值不同。请谨慎使用此类指令。也可能出现其它的差异，但这不常见。

跨翻译单元约束不仅仅应用于可以被定义在多个位置的实体，也适用于声明中的默认实参。也就是是说，下面的程序将产生未定义行为：

```c++
// ==== 翻译单元 1：
void unused(int = 3);

int main()
{
}

// ==== 翻译单元 2：
void unused(int = 4);
```

这里应该注意，记号序列的等价性有时会涉及微妙的隐含效果。下面的示例取自 C++ 标准（进行了微小的修改）：

```c++
// ==== 翻译单元 1：
class X {
  public:
    X(int, int);
    X(int, int, int);
};

X::X(int, int = 0)
{
}

class D {
    X x = 0;
};

D d1;  // D() 调用了 X(int, int)

// ==== 翻译单元 2：
class X {
  public:
    X(int, int);
    X(int, int, int);
};

X::X(int, int = 0, int = 0)
{
}

class D : public X {
    X x = 0;
};

D d2;    // D() 调用了 X(int, int, int)
```

这个例子中，问题发生的原因是类 `D` 隐式生成的默认构造函数在两个翻译单元中不同。一个调用了接受两个实参的 `X` 的构造函数，另一个调用了接受三个实参的 `X` 的构造函数。如果有的话，这个例子是一个额外的激励用于将默认实参限制在程序中的一个位置（如果可能，这个位置应该在头文件中）。幸运的是，在类定义外放置默认实参是一种罕见的做法。

规定相同标记必须指代相同实体的规则也有例外。如果相同的标记指代了值相同的无关常量，且结果表达式的地址没有被使用（甚至不能通过绑定引用到产生该常量的变量上来隐式使用），那么标记就被认为是等效的。这一例外允许程序的结构像下面这样：

```c++
// ==== header.hpp:
#ifndef HEADER_HPP
#define HEADER_HPP

int const length = 10;

class MiniBuffer {
  char buf[length];
  ...
};

#endif  // HEADER_HPP
```

原则上，当这一头文件被两个不同的翻译单元包含时，会创建两个不同的叫做 `length` 的常量，因为 `const` 在该上下文中指示 `static`。但是，这样的常量常常用于定义编译时常量值，而不是一个特定的运行时存储位置。因此，如果我们不（通过引用该变量的地址）强制这样的存储位置存在，则这两个常量有相同的值就足够了。

最后是一个关于模板的注意事项。模板中的名字会在两个阶段中被绑定。*非依赖名*（nondependent name）在模板定义的位置绑定。对于这些名字，等价性规则将按照和其它非模板定义相似的方式处理。对于在实例化点绑定的名字，等价性规则必须在实例化点应用，而且绑定必须等价。