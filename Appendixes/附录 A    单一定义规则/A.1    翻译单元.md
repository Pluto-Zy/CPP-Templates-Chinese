*单一定义规则*（one-definition rule）被亲切地称为 *ODR*，它是 C++ 程序结构良好的基石。很容易记住和应用 ODR 最常见的结果：非内联函数和对象在所有文件中只定义一次，而类、内联函数和内联变量在每个翻译单元最多定义一次，同时要确保相同实体的所有定义都相同。

然而，问题出于细节，当与模板实例化结合时，这些细节可能令人生畏。本附录旨在为感兴趣的读者提供 ODR 的全面概述。我们也指出了具体的相关问题是何时在正文中阐述的。

### A.1    翻译单元

实践中，我们通过用 “代码” 填充文件来编写 C++ 程序。但是，文件设定的边界在 ODR 的上下文中并不非常重要。相反，重要的是*翻译单元*（translation units）。本质上，翻译单元是将预处理器应用于你提供给编译器的文件的结果。预处理器删除了条件编译指令（`#if`，`#ifdef`，以及与之配对的部分）未选择的代码段，删除了注释，（递归地）插入了被 `#include` 的文件，并展开宏。

因此，就 ODR 而言，有下面两个文件

```c++
// ==== header.hpp:
#ifdef DO_DEBUG
 #define debug(x) std::cout << x << '\n'
#else
 #define debug(x)
#endif

void debugInit();
// ==== myprog.cpp:
#include "header.hpp"

int main()
{
    debugInit();
    debug("main()");
}
```

等价于下面的单个文件：

```c++
// ==== myprog.cpp:
void debugInit();

int main()
{
    debugInit();
}
```

跨翻译单元边界的连接是通过两个翻译单元中带有外部连接的对应声明来建立的（例如，全局函数 `debugInit()` 的两个声明）。

注意，翻译单元的概念要比 “被预处理过的文件” 更抽象一点。例如，如果我们将一个被预处理过的文件两次提供给编译器以形成单个程序，将会为程序带来两个不同的翻译单元（但是这样做没有意义）。