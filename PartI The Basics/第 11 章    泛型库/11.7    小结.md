### 11.7    小结

+ 模板允许你将函数、函数指针、函数对象、函子和 lambda 作为*可调用对象*（callable）传递；
+ 当定义一个类并带有重载的 `operator()` 时，将其声明为 `const`（除非这一调用改变了状态）；
+ 使用 `std::invoke()` 可以实现能处理所有可调用对象的代码，包括成员函数；
+ 使用 `decltype(auto)` 以完美转发返回值；
+ 类型萃取是检查类型的属性和功能的类型函数；
+ 当你在模板中需要一个对象的地址时，使用 `std::addressof()`；
+ 使用 `std::declval()` 以在不求值表达式中创建特定类型的值；
+ 如果泛型代码中的对象的类型不依赖于模板形参，就使用 `auto&&` 来完美转发它；
+ 要预备着处理模板形参是引用时的副作用；
+ 可以使用模板来延迟对表达式的求值（例如，为了支持在类模板中使用不完整类型）。