### 10.3    声明和定义

到现在为止，单词*声明*（declaration）和*定义*（definition）在本书中仅仅使用了几次。但是，这些词在 C++ 标准中有相当精确的含义，这也正是我们所使用的含义。

*声明*（declaration）是一种 C++ 构造，将名称引入或重引入到一个 C++ 作用域中。这一引入始终包括对该名字的部分分类，但有效的声明不需要细节。例如：

```c++
class C;		// C 的声明，作为类
void f(int p);	// f() 的声明，作为函数，且 p 作为具名形参
extern int v;	// v 的声明，作为变量
```

注意，尽管宏定义和 `goto` 标签都具有 “名字”，它们在 C++ 中也不认为是声明。

当声明的结构细节已知时，或者是对于变量，必须分配存储空间时，声明就变成了*定义*（definition）。对于类类型的定义，这表示必须提供一个花括号包围的主体。对于函数定义，这表示（在一般情况下）必须提供一个花括号包围的主体，或者函数必须被指定为 `= default` [^2] 或 `= delete`。对于变量，提供初始化或不提供 `extern` 说明符都会导致声明成为定义。下面的示例对前面的非定义声明进行补充：

[^2]:预置的函数是特殊成员函数，编译器会为其提供默认实现，例如预置的复制构造函数。

```c++
class C {};				// 类 C 的定义（和声明）

void f(int p) {			// 函数 f() 的定义（和声明）
  std::cout << p << '\n';
}

extern int v = 1;		// 初始化器使得这是 v 的定义

int w;					// 没有前置 extern 的全局变量声明也是定义
```

作为扩展，类模板或函数模板的声明在拥有主体的情况下叫做定义。因此，

```c++
template<typename T>
void func (T);
```

是声明，但不是定义，而

```c++
template<typename T>
class S {};
```

实际上是定义。

#### 10.3.1    完整类型和不完整类型

类型可以是*完整的*（complete）或*不完整的*（incomplete），这是一个与*声明*和*定义*之间的区别密切相关的概念。一些语言构造要求*完整类型*（complete type），其它则在提供*不完整类型*（incomplete type）时也有效。

不完整类型是下面其一：

+ 声明但尚未定义的类类型。
+ 未知边界的数组类型。
+ 元素类型不完整的数组类型。
+ `void`
+ 没有定义基础类型或枚举值的枚举类型。
+ 施加了 `const` 和/或 `volatile` 的任何上述类型。

所有其它类型都是*完整的*（complete）。例如：

```c++
class C;				// C 是一个不完整类型
C const* cp;			// cp 是一个指向不完整类型的指针
extern C elems[10];		// elems 具有不完整类型
extern int arr[];		// arr 具有不完整类型
...
class C { };			// C 现在是一个完整类型了
						// （因此，cp 和 elems 不再指代不完整类型）
int arr[10];			// arr 现在具有完整类型
```

有关如何处理模板中不完整类型的提示，见（原书）171 页 11.5 节。