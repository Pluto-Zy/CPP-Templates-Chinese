### 3.3    非类型模板形参的限制

非类型模板形参会存在一些限制。通常，它们只能是整数常量值（包括枚举）、指向对象/函数/成员的指针、对象或函数的左值引用，或者 `std::nullptr_t`（`nullptr` 的类型）。

不允许将浮点数和类类型对象作为非类型模板形参：

```c++
template<double VAT>			//错误：浮点数不允许作为模板形参
double process (double v)
{
    return v * VAT;
}

template<std::string name>		//错误：类类型对象不允许作为模板形参
class MyClass {
  ...  
};
```

将模板实参传递给指针或引用时，不能是字符串字面值、临时量或数据成员和其它子对象。因为在 C++17 前的每个 C++ 版本中，都对这些限制有所放宽，那么不同版本的额外限制是：

+ 在 C++11 中，对象也必须有外部连接；
+ 在 C++14 中，对象也必须有外部或内部连接。

因此，下面的情况是不可能的：

```c++
template<char const* name>
class MyClass {
  ...
};

MyClass<"hello"> x;		//错误：不允许使用字符串字面值 "Hello"
```

但是有一些解决方法（依赖于 C++ 版本）：

```c++
extern char const s03[] = "hi";		//外部连接
char const s11[] = "hi";			//内部连接

int main()
{
  Message<s03> m03;					//在所有版本中都正确
  Message<s11> m11;					//从 C++11 起正确
  static char const s17[] = "hi";	//无连接
  Message<s17> m17;					//从 C++17 起正确
}
```

上面的三种情况中，使用 `"hi"` 初始化了一个常量字符数组，并且将该对象用于一个声明为 `char const*` 的模板形参。如果该对象有外部连接（`s03`），那在所有 C++ 版本中都有效；在 C++11 和 C++14 中，如果它有内部连接（`s11`），或者从 C++17 起，它没有任何连接，那么也是有效的。

详细讨论见（原书）194 页 12.3.3 节，关于这一领域未来的可能变化的讨论见（原书）354 页 17.2 节。

##### 避免无效的表达式

非类型模板形参的实参必须是任何编译期表达式。例如：

```c++
template<int I, bool B>
class C;
...
C<sizeof(int) + 4, sizeof(int)==4> c;
```

但是要注意，如果在表达式中使用了 `operator>`，你就必须把整个表达式放入括号中，防止嵌套的 `>` 终止了实参列表：

```c++
C<42, sizeof(int) > 4> c;		//错误：首个 > 终止了模板实参列表
C<42, (sizeof(int) > 4)> c;		//正确
```

