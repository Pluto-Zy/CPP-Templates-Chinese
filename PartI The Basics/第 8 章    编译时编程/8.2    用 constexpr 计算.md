### 8.2    用 `constexpr` 计算

C++11 引入了一个新特性，`constexpr`，极大地简化了各种形式的编译时计算。特别是，给定合适的输入，就可以在编译时计算 `constexpr` 函数的值。虽然在 C++11 中引入的 `constexpr` 函数带有严格的限制（例如，每个 `constexpr` 函数的定义本质上都被限制为包含一个 `return` 语句），但是大多数限制都在 C++14 中被删除。当然，成功求值 `constexpr` 函数仍然要求所有计算步骤都在编译时可用，并有效：目前，这不包括堆内存分配或抛出异常之类的事情。

我们的用来测试一个数字是不是素数的例子可以在 C++11 中向下面这样实现：

*basics/isprime11.hpp*

```c++
constexpr bool
doIsPrime (unsigned p, unsigned d)	// p：要检查的数字，d：当前除数
{
  return d!=2 ? (p%d!=0) && doIsPrime(p,d-1)	// 检查当前除数和更小的除数
              : (p%2!=0);						// 如果除数是 2，结束递归
}

constexpr bool isPrime (unsigned p)
{
  return p < 4 ? !(p<2)				// 处理特殊情况
               : doIsPrime(p,p/2);	// 从除数为 p/2 开始递归
}
```

由于限制了只有一个语句，我们只能使用条件运算符作为选择机制，并仍然需要递归来迭代元素。但使用的语法是普通的 C++ 函数代码，这比我们依赖于模板实例化的第一个版本更容易理解。

在 C++14 中，`constexpr` 函数可以使用一般 C++ 代码中可用的大多数控制结构。因此，我们现在可以使用简单的 `for` 循环，而不是编写笨重的模板代码或有些神秘的单行代码：

*basics/isprime14.hpp*

```c++
constexpr bool isPrime (unsigned int p)
{
  for (unsigned int d=2; d<=p/2; ++d) {
    if (p % d == 0) {
      return false;	// 找到了没有余数的除数
    }
  }
  return p > 1;		// 找不到没有余数的除数
}
```

在我们的 `constexpr` 函数 `isPrime()` 的 C++11 和 C++14 版本实现中，我们都可以简单地调用

```c++
isPrime(9)
```

来确认 `9` 是不是素数。注意这可以在编译期完成，但并不是必须这么做。在需要编译时值的上下文中（如数组长度或非类型模板实参），编译器会尝试在编译时计算对 `constexpr` 函数的调用结果，并在做不到时（因为最终必须产生一个常量）报告问题。在其它上下文中，编译器可以尝试在编译时求值，也可以不这么做。[^3] 但是如果这样的求值失败了，就不会报告错误，并且将该调用留作运行时调用。

[^3]:在 2017 年写这本书的时候，即使不是绝对必要的，编译器似乎也确实会尝试在编译时求值。

例如：

```c++
constexpr bool b1 = isPrime(9);		// 在编译时求值
```

将在编译时计算其值。同理，

```c++
const bool b2 = isPrime(9);			// 如果在命名空间作用域，就会在编译时求值
```

在 `b2` 被定义在全局或命名空间中时也是如此。在块作用域中，编译器可以决定在编译时或运行时计算值。[^4] 例如，这里也是同样的情况：

```c++
bool fiftySevenIsPrime() {
  return isPrime(57);				// 在编译时或运行时求值
}
```

编译器可以在编译时求值对 `isPrime` 的调用，也可以不这样做。

[^4]:理论上，即使使用 `constexpr`，编译器也可以决定在运行时计算 `b` 的初始值。编译器只需要检查它是否可以在编译时计算该值。

另一方面：

```c++
int x;
...
std::cout << isPrime(x);			// 在运行时求值
```

将会生成在运行时计算 `x` 是否是素数的代码。