### 8.4    SFINAE（替换失败不是错误）

在 C++ 中，重载函数来解释不同的实参类型是很常见的。当编译器看到对重载函数的调用时，它必须单独考虑每个候选函数，评估调用所使用的实参，并从候选函数中选择最匹配的（关于这个过程的细节，参见附录 C）。

如果一个调用的候选函数集合中包含函数模板，编译器首先应该确定该候选函数应该使用什么模板实参，然后在函数形参列表和返回类型中替换这些实参，随后评估匹配程度（就像一个普通的函数）。但是，替换过程可能会遇到问题：可能产生没有意义的结构。语言规则不认为这种无意义的替换会导致错误，而是认为带有这种替换问题的候选函数会被简单地忽略。

我们把这一准则叫做 ***SFINAE***（发音就像 sfee-nay），代表 “替换失败不是错误”。

注意，这里描述的替换过程与按需实例化过程（见原书 27 页 2.2 节）不同：即使是对于不需要的潜在实例化，也可能发生替换（因此，编译器可以评估它们是否真的不需要）。它是直接出现在函数声明中（但不是函数体）的结构的替换。

看下面的例子：

*basics/len1.hpp*

```c++
// 原始数组中的元素个数
template<typename T, unsigned N>
std::size_t len (T(&)[N])
{
  return N;
}

// 对于含有 size_type 的类型，其保存的元素个数
template<typename T>
typename T::size_type len (T const& t)
{
  return t.size();
}
```

这里，我们定义了两个函数模板 `len()`，接受一个泛型实参：[^5]

[^5]:我们没有把函数命名为 `size()`，因为我们想要避免和 C++ 标准库的名字冲突。从 C++17 起，标准库定义了一个标准函数模板 `std::size()`。

1. 第一个函数模板将形参声明为 `T(&)[N]`，这表示该形参必须是一个有 `N` 个类型为 `T` 的元素的数组。
2. 第二个函数模板简单地将形参声明为 `T`，并没有对形参施加约束，但是返回值类型为 `T::size_type`，这要求传递的实参类型必须有对应的成员 `size_type`。

当传递原始数组或字符串字面值时，只有用于原始数组的函数模板匹配：

```c++
int a[10];
std::cout << len(a);		// 正确：只有用于数组的 len() 匹配
std::cout << len("tmp");	// 正确：只有用于数组的 len() 匹配
```

根据其签名，第二个函数模板在（分别）用 `int[10]` 和 `char const[4]` 替换 `T` 时，也能匹配，但是这些替换会导致返回类型 `T::size_type` 中的潜在错误。因此，在这些调用中，第二个模板会被忽略。

当传递 `std::vector<>`，只有第二个函数模板会匹配：

```c++
std::vector<int> v;
std::cout << len(v);		// 正确：只有用于带有 size_type 的类型的 len() 才匹配
```

当传递原始指针时，两个模板都不匹配（不产生错误）。结果就是，编译器会报告没有找到匹配的 `len()` 函数：

```c++
int* p;
std::cout << len(p);		// 错误：没有找到匹配的 len() 函数
```

注意，这与传递具有 `size_type` 成员但没有 `size()` 成员函数的类型的对象不同，例如，`std::allocator<>` 的情况：

```c++
std::allocator<int> x;
std::cout << len(x);		// 错误：找到了 len() 函数，但不能获取 size()
```

当传递这样的类型的对象时，编译器将第二个函数模板确定为匹配的函数模板。所以这会导致一个在 `std::allocator<int>` 上调用不合法的 `size()` 的编译时错误，而不是报告找不到匹配的 `len()` 函数。这次，第二个函数模板不会被忽略。

当替换返回类型没有意义时忽略该候选函数，会导致编译器选择另一个形参的匹配程度更差的候选函数。例如：

*basics/len2.hpp*

```c++
// 原始数组中的元素个数
template<typename T, unsigned N>
std::size_t len (T(&)[N])
{
  return N;
}

// 对于含有 size_type 的类型，其保存的元素个数
template<typename T>
typename T::size_type len (T const& t)
{
  return t.size();
}

// 所有其它类型：
std::size_t len (...)
{
  return 0;
}
```

这里，我们也提供了一个一般的 `len()` 函数，它永远能产生匹配，但匹配程度最差（在重载决议中对省略号（`...`）匹配，参见原书 682 页 C.2 节）。

因此，对于原始数组和向量，且特定的匹配更佳。对于指针，只有用于所有其它类型的函数能匹配，所以编译器不会再报告此次调用没有匹配的 `len()`。[^6] 但是对于分配器，第二个和第三个函数模板都匹配，而且第二个函数模板是更好的匹配。所以，这仍然会导致错误，即没有可被调用的 `size()` 成员函数：

[^6]:在实践中，这样的保底函数通常会提供更有用的默认值，或抛出异常，或包含一个静态断言以产生有用的错误信息。

```c++
int a[10];
std::cout << len(a);		// 正确：用于数组的 len() 是最佳匹配
std::cout << len("tmp");	// 正确：用于数组的 len() 是最佳匹配

std::vector<int> v;
std::cout << len(v);		// 正确：用于带有 size_type 的类型的 len() 是最佳匹配

int* p;
std::cout << len(p);		// 正确：只有最后的 len() 匹配

std::allocator<int> x;
std::cout << len(x);		// 错误：第二个 len() 函数匹配最佳
							//      但不能在 x 上调用 size()
```

关于 SFINAE 的更多细节，见（原书）284 页 15.7 节；关于 SFINAE 的一些应用，见（原书）416 页 19.4 节。

##### SFINAE 和重载决议

随着时间的推移，SFINAE 原则在模板设计者看来变得越来越重要和普遍，以至于其缩写已经成为了一个动词。我们会说 “我们 SFINAE 了一个函数”，用于表示我们使用了 SFINAE 机制，通过检测模板代码以在特定约束下产生无效代码，来确保函数模板在这些约束下被忽略。而在你阅读 C++ 标准时，每当一个函数模板要求 “不应参与重载决议，除非……”，就表示应该使用 SFINAE 以在某些情况下 “SFINAE” 该函数模板。

例如，类 `std::thread` 声明了一个构造函数：

```c++
namespace std {
 class thread {
  public:
   ...
   template<typename F, typename... Args>
     explicit thread(F&& f, Args&&... args);
   ...
 };
}
```

并带有下面的标注：

> 标注：该构造函数在 `decay_t<F>` 和 `std::thread` 是同一类型时，不参与重载决议。

这表示当使用 `std::thread` 作为第一个和唯一一个实参调用该模板构造函数时，它会被忽略。原因是，如果不这样做，像这样的成员模板有时可能比任何预定义的复制或移动构造函数更匹配（细节见原书 95 页 6.2 节和 333 页 16.2.4 节）。通过在用一个线程调用构造函数时使用 SFINAE 将其排除在外，我们确保在从另一个线程构造新线程时，始终使用预定义的复制或移动构造函数。[^7]

[^7]:因为类 `thread` 的复制构造函数被弃置，所以这也确保了复制被禁止。

逐个案例应用该技术可能很笨拙。幸运的是，标准库提供了更容易地禁用模板的工具。最著名的此类特性是在（原书）98 页 6.3 节介绍的 `std::enable_if<>`。我们仅需要用带有禁用它的条件的构造替换其类型，就能禁用模板。

因此，`std::thread` 的真正声明通常如下：

```c++
namespace std {
 class thread {
  public:
   ...
   template<typename F, typename... Args,
            typename = enable_if_t<!is_same_v<decay_t<F>,
                                                        thread>>>
     explicit thread(F&& f, Args&&... args);
   ...
 };
}
```

关于如何使用部分特化和 SFINAE 实现 `std::enable_if<>` 的细节，见（原书）469 页 20.3 节。

#### 8.4.1    带有 `decltype` 的表达式 SFINAE

对于某些条件，找出并制定正确的表达式用于 SFINAE 函数模板并不总是那么容易。

例如，假设我们想要确保在函数模板 `len()` 的实参类型满足这样的条件时被忽略：该类型拥有 `size_type` 成员，但没有 `size()` 成员函数。由于在函数声明中没有对 `size()` 成员函数的任何形式的要求，因此函数模板被选中，然后它最终的实例化会导致错误：

```c++
template<typename T>
typename T::size_type len (T const& t)
{
  return t.size();
}

std::allocator<int> x;
std::cout << len(x) << '\n';	// 错误：选择了 len()，但 x 没有 size()
```

有一种常见的模式或习语来处理这种情况：

+ 使用*尾置返回类型*（trailing return type）语法指定返回类型（在前面使用 `auto`，并在末尾处的返回类型前使用 `->`）。
+ 使用 `decltype` 和逗号运算符定义返回类型。
+ 在逗号运算符的开头指定所有必须有效的表达式（在逗号运算符被重载的情况下，转换为 `void`）。
+ 在逗号运算符的最后定义一个对象，其类型是真正的返回类型。

例如：

```c++
template<typename T>
auto len (T const& t) -> decltype( (void)(t.size()), T::size_type() )
{
  return t.size();
}
```

这里的返回值类型由

```c++
decltype( (void)(t.size()), T::size_type() )
```

给出。

`decltype` 构造的运算对象是一个由逗号分开的表达式的列表，因此最后一个表达式 `T::size_type()` 产生所需返回类型的值（`decltype` 用于将其转换为返回值类型）。在（最后一个）逗号前，我们使用了必须有效的表达式，在这里就是 `t.size()`。将表达式强制转换为 `void` 是为了避免用户定义的逗号运算符为表达式的类型重载的可能性。

注意 `decltype` 的实参是*不求值操作数*（unevaluated operand），这意味着，例如，你可以在不调用构造函数的情况下创建 “虚拟对象”，这在（原书）116 页 11.2.3 节讨论。