## 第 6 章    移动语义和 `enable_if<>`

C++11 引入的最突出的特性之一是*移动语义*（move semantics）。你可以使用移动语义，将内部资源从源对象移动（“窃取”）到目标对象，而不是复制它们，来实现对拷贝和赋值的优化。如果源对象不再需要它的内部值或状态（因为它即将被丢弃），就可以这样做。

移动语义对模板的设计有重要的影响，也引入了特殊的规则用于在泛型代码中支持移动语义。这一章将介绍这些特性。

### 6.1    完美转发

假设你想要编写一种能转发传递的实参的基本属性的泛型代码：

+ 可修改的对象应该被转发，这也它们仍能被修改；
+ 常量对象应该被转发为只读的对象；
+ 可移动的对象（由于这样的对象将结束生命，因此我们能从其“窃取”资源）应该被转发为可移动的对象。

为了在没有模板的情况下实现该功能，我们必须对所有的三种情况编程。例如，为了将对 `f()` 的一次调用转发给对应的函数 `g()`：

*basics/move1.cpp*

```c++
#include <utility>
#include <iostream>

class X {
  ...
};

void g (X&) {
  std::cout << "g() for variable\n";
}
void g (X const&) {
  std::cout << "g() for constant\n";
}
void g (X&&) {
  std::cout << "g() for movable object\n";
}

// 让 f() 将实参 val 转发给 g()
void f (X& val) {
  g(val);				//val 是一个非常量左值 => 调用 g(X&)
}
void f (X const& val) {
  g(val);				//val 是一个常量左值 => 调用 g(X const&)
}
void f (X&& val) {
  g(std::move(val));	//val 是一个非常量左值 => 需要 std::move 才能调用 g(X&&)
}
```

在这里，我们看到了 `f()` 的三种不同的实现，用于将其实参转发给 `g()`：

```c++
void f (X& val) {
  g(val);				//val 是一个非常量左值 => 调用 g(X&)
}
void f (X const& val) {
  g(val);				//val 是一个常量左值 => 调用 g(X const&)
}
void f (X&& val) {
  g(std::move(val));	//val 是一个非常量左值 => 需要 std::move 才能调用 g(X&&)
}
```

注意为可移动的对象编写的代码（通过*右值引用*（rvalue reference））和其它代码不同：它需要 `std::move()`，因为根据语言规则，移动语义不会被传递。[^1]尽管在第三个 `f()` 中的 `val` 被声明为右值引用，当其用作表达式时，其值类别仍然是一个非常量左值（见附录 B），且表现得像第一个 `f()` 中的 `val`。没有 `move()`，将调用为非常量左值准备的 `g(X&)` 而不是 `g(X&&)`。

[^1]:移动语义不会自动传递这一事实是有意且重要的。如果不是这样，我们将在第一次在函数中使用可移动对象时失去其值。

如果我们想要在泛型代码中结合所有的三种情况，将产生一个问题：

```c++
template<typename T>
void f (T& val) {
  g(val);
}
```

将在前两种情况下正常工作，但是在传递了可移动对象的第三种情况下不行。

出于这个原因，C++11 引入了*完美转发*（perfect forwarding）形参的特殊规则。实现这一功能的惯用代码模式如下：

```c++
template<typename T>
void f (T&& val) {
  g(std::forward<T>(val));		//将 val 完美转发给 g()
}
```

注意 `std::move()` 没有模板形参，并对传递的实参“触发”移动语义，而 `std::forward<>()` 根据传递的模板实参“转发”潜在的移动语义。

不要认为用于模板形参 `T` 的 `T&&` 和用于特定类型 `X` 的 `X&&` 行为相同。**它们应用了不同的规则！**但是，在语法上它们看起来相同：

+  用于特定类型 `X` 的 `X&&` 将形参声明为右值引用。它只能被绑定到可移动的对象上（纯右值，例如临时对象，和亡值，例如用 `std::move()` 传递的对象；细节见附录 B）。它将永远可变，你永远可以“窃取”其值。[^2]
+ 用于模板形参 `T` 的 `T&&` 声明了*转发引用*（forwarding reference）（也叫做*通用引用*（universal reference））。[^3]它可以被绑定到一个可变的、不可变的（如 `const`），或可移动的对象上。在函数定义中，这个形参可能是可变的、不可变的，或引用一个可以“窃取”内部信息的值。

[^2]:类似于 `X const&&` 的类型是可用的，但是在实践中没有提供通用的语义，因为“窃取”可移动对象的内部表示需要修改该对象。但是，它可以用于强制要求传递临时对象或带有 `std::move()` 标记的对象，而不去修改它们。
[^3]:术语*通用引用*（universal reference）由 Scott Meyers 提出的通用术语，其可表示“左值引用”或“右值引用”。由于“universal”太过通用，C++17 标准引入了术语*转发引用*（forwarding reference），因为使用这样一个引用的主要原因是转发对象。但是，注意它不会自动地转发。该术语没有描述它是什么，而是描述了它一般用于什么。

注意 `T` 必须实际上是一个模板形参的名字。仅依赖于模板形参是不够的。对于一个模板形参 `T`，声明 `typename T::iterator&&` 仅仅是右值引用，而不是转发引用。

因此，完美转发实参的完整程序看起来像下面这样：

*basics/move2.cpp*

```c++
#include <utility>
#include <iostream>

class X {
  ...
};

void g (X&) {
  std::cout << "g() for variable\n";
}
void g (X const&) {
  std::cout << "g() for constant\n";
}
void g (X&&) {
  std::cout << "g() for movable object\n";
}

// 让 f() 将实参 val 转发给 g()
template<typename T>
void f (T&& val) {
  g(std::forward<T>(val));		//对于任意给定的实参 val，都能调用正确的 g()
}

int main()
{
  X v;				//创建变量
  X const c;		//创建常量
    
  f(v);				//用于变量的 f() 调用 f(X&)  => 调用 g(X&)
  f(c);				//用于常量的 f() 调用 f(X const&)  => 调用 g(X const&)
  f(X());			//用于临时量的 f() 调用 f(X&&)  => 调用 g(X&&)
  f(std::move(v));	//用于可移动变量的 f() 调用 f(X&&)  => 调用 g(X&&)
}
```

当然，完美转发也可以用于变参模板（一些示例见原书 60 页 4.3 节）。完美转发的详细内容见（原书）280 页 15.6.3 节。