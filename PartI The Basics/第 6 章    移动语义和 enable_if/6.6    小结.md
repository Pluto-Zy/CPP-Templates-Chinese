### 6.6    小结

+ 在模板中，你可以将形参声明为*转发引用*（forwarding references）（使用由模板形参的名字组成的类型，并后随 `&&`），从而“完美”转发形参，并在被转发的调用中使用 `std::forward<>()`；
+ 使用完美转发的成员函数模板复制或移动对象时，它们可能比预定义的特殊的成员函数匹配更优；
+ 使用 `std::enable_if<>` 可以在一个编译时条件为 `false` 时禁用函数模板（一旦条件确定，该模板就会被忽略）；
+ 当可以由单个参数调用的构造函数模板或赋值运算符模板比隐式合成的特殊成员函数匹配更好时，可以使用 `std::enable_if<>` 避免出现问题；
+ 通过弃置为 `const volatile` 预定义的特殊成员函数，你可以模板化（并应用 `enable_if<>`）特殊的成员函数；
+ 概念能使我们对函数模板的要求使用更直观的语法。

