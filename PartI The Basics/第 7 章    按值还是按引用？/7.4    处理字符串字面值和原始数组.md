### 7.4    处理字符串字面值和原始数组

至此，我们已经看到了在使用字符串字面值和原始数组作为模板形参时的不同效果：

+ 按值传递调用时会退化，它们会称为指向元素类型的指针。
+ 任何形式的按引用传递调用都不会退化，实参成为引用，仍然绑定到数组上。

这两种各有好坏。当数组退化为指针时，就无法区分处理指向元素的指针和处理传递的数组的不同情况。另一方面，在处理可能传递字符串字面值的参数时，不退化可能会产生问题，因为不同大小的字符串字面值有不同的类型。例如：

```c++
template<typename T>
void foo (T const& arg1, T const& arg2)
{
  ...
}

foo("hi", "guy");	//错误
```

这里的 `foo("hi", "guy")` 编译失败，因为 `"hi"` 的类型为 `char const[3]`，而 `"guy"` 的类型为 `char const[4]`，但是模板要求它们都拥有相同的类型 `T`。只有在字符串字面值长度相同时，这样的代码才能通过编译。因此，强烈建议在测试用例中使用不同长度的字符串字面值。

通过将函数模板 `foo()` 声明为按值传递实参，函数调用就可以正常进行了：

```c++
template<typename T>
void foo (T arg1, T arg2)
{
  ...
}

foo("hi", "guy");		//能编译，但是……
```

**但是**，这并不意味着所有的问题都解决了。更糟的是，编译时问题可能变成了运行时问题。考虑下面的代码，其中我们使用 `operator==` 比较传递的实参：

```c++
template<typename T>
void foo (T arg1, T arg2)
{
  if (arg1 == arg2) {	//哎呀：比较传递的数组的地址
    ...
  }
}

foo("hi", "guy");		//能编译，但是……
```

正如所写的，你必须知道应该将传递的字符指针解释为字符串。但是这可能是大部分的情况，因为模板也要处理来自已经退化的字符串字面值的实参（例如，来自另一个按值调用的函数，或复制给用 `auto` 声明的对象）。

然而，在许多情况下，退化是有帮助的，特别是在检查两个对象（都作为实参传递，或者一个作为实参传递，另一个期望该实参）是否具有或能转换为相同类型时。一个典型的用法是完美转发。但是如果你想使用完美转发，就必须将形参声明为转发引用。在这些情况下，你可以使用类型萃取 `std::decay<>` 显式地使实参退化。具体的示例见（原书）120 页 7.6 节关于 `std::make_pair()` 的故事。

注意，其它的类型萃取有时也会隐式地退化，例如 `std::common_type<>`，它返回两个传递的实参类型的公共类型（见原书 12 页 1.3.3 节和原书 732 页 D.5 节）。

#### 7.4.1    针对字符串字面值和原始数组的特殊实现

你可能需要根据传入了指针还是数组来区分你的实现。当然，这要求传递的数组尚未退化。

为了区分这些情况，你必须检测是否传递了数组。基本上，有两个选择：

+ 你可以将模板形参声明为只对数组有效：

  ```c++
  template<typename T, std::size_t L1, std::size_t L2>
  void foo(T (&arg1)[L1], T (&arg2)[L2])
  {
    T* pa = arg1;		//退化 arg1
    T* pb = arg2;		//退化 arg2
    if (compareArrays(pa, L1, pb, L2)) {
      ...
    }
  }
  ```

  这里，`arg1` 和 `arg2` 必须是拥有相同元素类型 `T`、不同大小 `L1` 和 `L2` 的原始数组。但是，你可能需要多个实现以支持各种形式的原始数组（见原书 71 页 5.4 节）。

+ 你可以使用类型萃取检测是否传递了数组（或指针）：

  ```c++
  template<typename T,
           typename = std::enable_if_t<std::is_array_v<T>>>
  void foo (T&& arg1, T&& arg2)
  {
    ...
  }
  ```

  由于这些特殊处理，通常用不同方式处理数组的最佳方法就是使用不同的函数名称。当然，更好的做法是确保模板的调用者使用 `std::vector` 或 `std::array`。但是只要字符串字面值是原始数组，我们就必须永远考虑它们。