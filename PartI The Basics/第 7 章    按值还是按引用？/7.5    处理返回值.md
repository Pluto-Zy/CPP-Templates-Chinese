### 7.5    处理返回值

对于返回值，你也可以决定按值返回还是按引用返回。返回引用可能带来麻烦，因为你引用了一些不受控制的东西。在一些情况下，返回引用是常见的编程实践：

+ 返回容器或字符串的元素（例如，通过 `operator[]` 或 `front()`）
+ 确保对类成员的可写
+ 用于链式调用（用于流的 `operator<<` 和 `operator>>`，以及一般情况下类对象的 `operator=`）

此外，返回常量引用以提供对成员的可读权限也是很常见的。

注意，如果用法错误，上面的这些情况都可能带来问题。例如：

```c++
std::string* s = new std::string("whatever");
auto& c = (*s)[0];
delete s;
std::cout << c;		// 运行时错误
```

这里，我们获取了字符串的一个元素的引用，但是在我们使用这个引用时，底层字符串不再存在（即创建了一个*悬垂引用*），从而产生未定义行为。这个例子是人为的（有经验的程序员可能会立刻注意到问题），但是问题很容易就变得不那么明显了。例如：

```c++
auto s = std::make_shared<std::string>("whatever");
auto& c = (*s)[0];
s.reset();
std::cout << c;		// 运行时错误
```

因此，我们应该确保函数模板按值返回结果。但是，正如这一章讨论的，使用模板形参 `T` 不保证它不是引用，因为 `T` 有时可能被隐式地推导为引用：

```c++
template<typename T>
T retR(T&& p)	// p 是一个转发引用
{
  return T{...};	// 哎呀：当使用左值调用时，将按引用返回
}
```

即使 `T` 是在按值调用中推导出来的模板形参，当显示指定模板形参为引用时，它也可能成为引用类型：

```c++
template<typename T>
T retV(T p)		// 注意：T 可能是引用
{
  return T{...};	//哎呀：如果 T 是引用，将按引用返回
}

int x;
retV<int&>(x);		// 使用 int& 作为 T 实例化 retT()
```

安全起见，你有两个选择：

+ 使用类型萃取 `std::remove_reference<>`（见原书 729 页 D.4 节）将 `T` 转换为非引用类型：

  ```c++
  template<typename T>
  typename std::remove_reference<T>::type retV(T p)
  {
    return T{...};	// 永远按值返回
  }
  ```

  其它的萃取（例如 `std::decay<>`，见原书 731 页 D.4 节）也可以用在这里，因为它们也会隐式地移除引用。

+ 将返回值类型声明为 `auto` 从而让编译器推导它（从 C++14 起；见原书 11 页 1.3.2 节），因为 `auto` 永远会退化：

  ```c++
  template<typename T>
  auto retV(T p)	// 由编译器推导出的按值返回的类型
  {
    return T{...};	// 永远按值返回
  }
  ```

  