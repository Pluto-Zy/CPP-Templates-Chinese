### 5.2    零初始化

对于类似于 `int`、`double` 或指针类型这样的基础类型，是没有一个使用有用的默认值将其初始化的默认构造函数的。恰恰相反，所有未初始化的局部变量都拥有未定义的值：

```c++
void foo()
{
  int x;		//x 有未定义的值
  int* ptr;		//ptr 可能指向任何位置（而不是哪里也不指向）
}
```

现在，如果你写了一个模板，而且想要使用默认值初始化模板类型的变量，那么就会遇到问题，即简单的定义并不会为内置类型做初始化工作：

```c++
template<typename T>
void foo()
{
  T x;		//如果 T 是内置类型，x 的值未定义
}
```

出于这个原因，显式为内置类型调用默认构造函数是可能的，这会用零对它们进行初始化（或者对于 `bool` 使用 `false`，对于指针使用 `nullptr`）。因此，即使是对于内置类型，你也可以用下面的方式确保正确的初始化：

```c++
template<typename T>
void foo()
{
  T x{};	//如果 T 是一个内置类型，那么 x 是 0（或 false 或 nullptr）
}
```

这种初始化方式叫做值初始化（value initialization），这表示，要么调用一个提供的构造函数，要么零初始化（zero initialize）一个对象。在构造函数是 `explicit` 的情况下也能正常工作。

在 C++11 前，确保正确初始化的语法是

```c++
T x = T();		//如果 T 是一个内置类型，那么 x 是 0（或 false 或 nullptr）
```

在 C++17 前，该机制（现在仍然存在）只有在复制初始化选择的构造函数不是 `explicit` 时才工作。在 C++17 中，受保证的复制消除避免了这一限制，因此两种语法都是正确的，但是花括号初始化的形式在没有可用的默认构造函数时还可以使用初始化列表构造函数[^1]。

[^1]:也就是一个形参类型为 `std::initializer_list<X>` 的构造函数，`X` 是某种类型。

为了确保类模板中某个类型被参数化了的成员能被初始化，你可以定义一个使用花括号初始化器初始化该成员的默认构造函数：

```c++
template<typename T>
class MyClass {
  private:
    T x;
  public:
    MyClass() : x{} {	//确保即使是内置类型，x 也被初始化
    }
    ...
};
```

C++11 前的语法

```c++
MyClass() : x() {		//确保即使是内置类型，x 也被初始化
}
```

也能正确进行。

从 C++11 起，你也可以为非静态数据成员提供默认初始化器，所以下面的代码也是可以的：

```c++
template<typename T>
class MyClass {
  private:
    T x{};			//如果不另外指定，就零初始化 x
    ...
};
```

但是，默认实参不能使用这样的语法，例如，

```c++
template<typename T>
void foo(T p{}) {		//错误
    ...
}
```

我们必须这样写：

```c++
template<typename T>
void foo(T p = T{}) {	//正确（C++11 前必须使用 T()）
    ...
}
```

