### 5.8    小结

+ 为了访问一个依赖于模板形参的类型名，你必须用一个前置的 `typename` 限定该名字；
+ 为了访问依赖于模板形参的基类的成员，你必须用 `this->` 或它们的类名限定该访问；
+ 嵌套类和成员函数也可以是模板。一种应用是能够通过内部类型转换实现泛型操作；
+ 模板形式的构造函数或赋值运算符不会代替预定义的构造函数或赋值运算符；
+ 通过使用花括号初始化或显式调用默认构造函数，你可以确保使用默认值初始化变量和模板的成员，即使它们用内置类型实例化；
+ 你可以为原始数组提供特定的模板，这也适用于字符串字面值；
+ 传递原始数组或字符串字面值时，当且仅当形参不是一个引用时，实参会在实参推导期间退化（执行数组到指针转换）；
+ 你可以定义*变量模板*（variable template）（从 C++14 起）；
+ 你也可以将类模板作为模板形参，即*模板模板形参*（template template parameter）；
+ 模板模板实参通常必须精确匹配它们的形参。

