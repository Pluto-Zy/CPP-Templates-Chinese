### 1.6    但是，难道我们不应该……？

也许，即使是这些简单的函数模板示例，也会引发其它问题。我们应该简单地讨论三个很常见的问题。

#### 1.6.1    传值还是传引用？

你可能好奇，为什么我们声明的函数一般都是按值传递实参，而不是通过引用传递。通常，对于拷贝廉价的简单类型（如基本类型或 `std::string_view`）以外的类型，推荐使用引用传递，因为这不会创建不需要的副本。

但是，出于一些原因，一般情况下值传递会更好：

+ 语法简单；
+ 编译器能更好地优化；
+ 移动语义通常能降低拷贝的成本；
+ 有时不会产生任何拷贝或移动。

而且，对于模板，还有一些特殊方面的原因：

+ 模板可能被用于简单类型和复杂类型，因此如果为复杂类型选择了好的解决方法，可能会对简单类型而言适得其反；
+ 作为调用者，你往往可以使用 `std::ref()` 和 `std::cref()` （见 112 页的 7.3 节）实现按引用传递参数；
+ 尽管传递文本字符串或内置数组常常会产生问题，但通常认为通过引用传递它们会导致更大的问题。

我们会在第 7 章详细讨论这些内容。现在，在本书中，除了某些只能使用引用传递的功能，我们都会按值传递参数。

#### 1.6.2    为什么不用 `inline`？

通常情况下，函数模板不需要声明成 `inline`。不像普通的非内联函数，我们能在头文件中定义非内联的函数模板，并且能在多个翻译单元中包含这个头文件。

这条规则唯一的例外是模板对于某些类型的全特化，这导致最终的代码不再是泛型的（所有的模板形参都被定义了）。更多细节请见（原书）140 页的 9.2 节。

从严格的语言规定角度来看，`inline` 仅仅表示某个函数定义可以在一个程序中多次出现。但是，这也表示对编译器的指示，即对该函数的调用应该“被内联地展开”：这样做可以在一些特定情况下产生更高效的代码，但也可能在许多其它情况下降低代码的效率。现如今的编译器在没有关键字 `inline` 的暗示下也能很好地决定是否进行内联展开。不过，当 `inline` 出现时，编译器还是会考虑它。

#### 1.6.3    为什么不用 `constexpr`？

自 C++11 起，你可以使用 `constexpr` 提供某段代码在编译期计算某些值的能力。对于一些模板，这很有意义。

例如，为了能在编译期使用求最大值的函数，你就要像下面这样声明它：

*basics/maxconstexpr.hpp*

```c++
template<typename T1, typename T2>
constexpr auto max (T1 a, T2 b)
{
  return  b < a ? a : b;
}
```

有了它，你就可以在编译期执行的上下文中使用这个求最大值的函数模板了，例如，声明一个内置数组的大小时：

```c++
int a[::max(sizeof(char),1000u)];
```

或者声明 `std:array<>` 的大小时：

```c++
std::array<std::string, ::max(sizeof(char),1000u)> arr;
```

注意，这里我们将 1000 作为 `unsigned int` 传递给函数模板，这能抑制模板内比较一个有符号数和一个无符号数时产生的警告。

在（原书）125 页 8.2 节将讨论使用 `constexpr` 的其它例子。但是，为了保持对基础知识的关注，在讨论其它模板特性时，我们常常会跳过 `constexpr`。