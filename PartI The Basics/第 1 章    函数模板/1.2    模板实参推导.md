### 1.2    模板实参推导

当我们使用一些实参调用 `max()` 这样的函数模板时，模板形参由我们传递的函数实参决定。如果我们传递了两个 `int` 给 `T` 类型的形参，C++ 编译器就会推断出 `T` 一定是 `int`。

但是，`T` 可能只是类型的“一部分”。例如，如果我们使用常量引用声明 `max()`：

```c++
template<typename T>
T max (T const& a, T const& b)
{
    return  b < a ? a : b;
}
```

然后传递 `int` 参数，那么 `T` 会被推断为 `int`，因为函数形参与 `int const&` 是匹配的。

##### 类型推导期间的类型转换

在类型推导时，自动的类型转换是受限制的：

+ 如果采用引用类型声明调用参数，即使是平凡的类型转换也不适用于类型推导。用相同的模板参数 `T` 声明的两个实参必须精确匹配；
+ 如果采用值类型声明调用参数，则只允许退化（decay）这个平凡的类型转换：`const` 或 `volatile` 限定被忽略，引用将被转换为被引用的类型，内置数组或函数会被转换成对应的指针类型。用相同的模板参数 `T` 声明的两个实参，其退化后的类型必须匹配。

例如：

```c++
template<typename T>
T max (T a, T b);
...
int i = 17;
int const c = 42;
max(i, c);			//OK: T 被推导为 int
max(c, c);			//Ok: T 被推导为 int
int& ir = i;
max(i, ir);			//OK: T 被推导为 int
int arr[4];
max(&i, arr);		//OK: T 被推导为 int*
```

但是，这些是错误的：

```c++
max(4, 7.2);		//错误：T 可以被推导为 int 或 double
std::string s;
max("hello", s);	//错误：T 可以被推导为 char const* 或 std::string
```

有 3 种方式处理这类错误：

1. 转换实参类型，使其匹配：

   ```c++
   max(static_cast<double>(4), 7.2);	//OK
   ```

2. 显式指定（或限定）类型 `T`，以抑制编译器进行类型推导：

   ```c++
   max<double>(4, 7.2);				//OK
   ```

3. 指出参数可能有不同的类型。

（原书）第 9 页的 1.3 节将详细介绍这些选择。（原书）第 108 页的 7.2 节和第 15 章将讨论类型推导期间的类型转换的规则细节。

##### 默认实参的类型推导

函数的默认调用实参不参与类型推导。例如：

```c++
template<typename T>
void f(T = "");
...
f(1);				//OK: T 推导为 int，调用 f<int>(1)
f();				//错误：无法推导 T
```

为了支持这种情况，你需要为模板形参声明默认实参，这会在（原书）第 13 页的 1.4 节讨论：

```c++
template<typename T = std::string>
void f(T = "");
...
f();				//OK
```

