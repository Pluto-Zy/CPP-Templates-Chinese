### 9.5    后记

头文件和 CPP 文件中的源代码的组织是*单一定义规则*（one-definition rule）或 *ODR* 的各种变式的结果。附录 A 对这一规则进行了详细的讨论。

C++ 编译器实现的现有实践决定了包含模型是一个实用的答案。但是，第一个 C++ 实现是不同的：模板定义被隐式包含，这造成了某种*分离*的错觉（关于这一原始模型的细节，见第 14 章）。

第一个 C++ 标准（[C++98]）通过*导出模板*（exported templates）提供了对模板编译的*分离模型*（separation model）的显式支持。分离模型允许带有 `export` 标记的模板声明置于头文件，而对应的定义置于 CPP 文件，非常像非模板代码的声明和定义。不同于包含模型，分离模型是一个不基于任何现有实现的理论模型，而且实现本身被证明比 C++ 标准委员会预期的要复杂得多。它的第一个实现的发布（2002 年 5 月）用了五年多的时间，并且在此后的几年中再也没见到其它的实现了。为了更好地保持 C++ 标准和现有实现的一致，C++ 标准委员会从 C++11 中移除了导出模板。我们鼓励有兴趣了解更多分离模型的细节（和陷阱）的读者阅读本书第一版（[VandevoordeJosuttisTemplates1st]）的 6.3 和 10.3 节。

有时很容易想到扩展预编译头文件的概念的方法，以便于可以为单次编译加载多个头文件。原则上，这将允许更细粒度的预编译方法。这里的障碍主要来自于预处理器：一个头文件中的宏可以完全改变后续头文件的含义。然而，一旦一个文件被预编译，宏的处理就完成了，而为了其它头文件引起的预处理器的效果而尝试修补预编译头文件是几乎不切实际的。预计在不久的将来，一种称为模块的新的语言特性（见原书 366 页 17.11 节）将会被添加到 C++ 中以解决该问题（宏定义不能泄露到模块接口中）。

