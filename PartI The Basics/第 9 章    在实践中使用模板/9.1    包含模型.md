## 第 9 章    在实践中使用模板

模板代码和普通代码有一点不同。在某些方面，模板介于宏和普通（非模板）声明之间。虽然这可能过于简单化，但它会影响我们使用模板编写算法和数据结构的方法，以及涉及模板的表达和分析程序的日常逻辑。

在本章中，我们将讨论涉及模板的一些实践，且不必深入研究背后的技术细节。第 14 章讨论了其中的许多细节。为了保证讨论的简单，我们假定我们的 C++ 编译系统由相当传统的编译器和链接器组成（不属于这一类的 C++ 系统很少见）。

### 9.1    包含模型

由很多方式组织模板源代码。这一节展示了最常用的方法：包含模型。

#### 9.1.1    链接器错误

大多数 C 和 C++ 程序员主要按照下面的方法组织他们的非模板代码：

+ 类和其它类型声明整个放在*头文件*（header files）中。一般情况下，这是一个带有 `.hpp`（或 `.H`、`.h`、`.hh`、`.hxx`）文件扩展名的文件。
+ 对于全局（非内联）变量和（非内联）函数，头文件中只放一个声明，而将定义放在编译为自己的翻译单元的文件中。这样的 CPP 文件通常带有 `.cpp`（或 `.C`、`.c`、`.cc` 或 `.cxx`）文件扩展名。

这能很好地工作：它使得所需的类型定义在整个程序中轻松可用，并且避免了来自链接器的变量和函数重复定义错误。

按照这些约定，下面的（错误的）小程序说明了新手模板程序员抱怨的常见错误。与 “普通代码” 一样，我们在头文件中声明模板：

*basics/myfirst.hpp*

```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

// 模板的声明
template<typename T>
void printTypeof (T const&);

#endif // MYFIRST_HPP
```

`printTypeof()` 是一个简单的辅助函数声明，该函数打印一些类型信息。该函数的实现放在了 CPP 文件中：

*basics/myfirst.cpp*

```c++
#include <iostream>
#include <typeinfo>
#include "myfirst.hpp"

// 模板的实现/定义
template<typename T>
void printTypeof (T const& x)
{
    std::cout << typeid(x).name() << '\n';
}
```

这个例子使用了 `typeid` 运算符来打印描述传递给它的表达式的类型的字符串。它返回静态类型为 `std::type_info` 的左值，其提供了一个成员函数 `name()` 用于显式表达式的类型。C++ 标准并没有说 `name()` 必须返回有意义的内容，但是在好的 C++ 实现中，你应该得到一个对传递给 `typeid` 的表达式的类型给出了很好描述的字符串。[^1]

[^1]:在一些实现中，这个字符串被*重整*（mangle）了（用实参的类型和包围它的作用域的名字编码，来区分它和其它名字），但是可以进行*解除重整*（demangle）从而将其转换为人类可读的文本。

最后，我们在另一个 CPP 文件中使用该模板，我们的模板声明被 `#include` 进来：

*basics/myfirstmain.cpp*

```c++
#include "myfirst.hpp"

// 使用模板
int main()
{
    double ice = 3.0;
    printTypeof(ice);	// 使用类型 double 调用函数模板
}
```

C++ 编译器很有可能接受该程序，并不报告任何错误，但链接器很可能会报告错误，指出没有函数 `printTypeof()` 的定义。

该错误出现的原因是，函数模板 `printTypeof()` 的定义没有被实例化。为了实例化一个模板，编译器必须知道应该实例化哪个定义，以及应该用什么模板实参实例化。不幸的是，在前面的例子中，这两类信息在分开编译的其它文件中。因此，当我们的编译器看到对 `printTypeof()` 的调用但没有用 `double` 实例化该函数所需的定义时，它就会认为这样的定义在别的地方提供，并创建到该定义的引用（用于链接器解析）。另一方面，当编译器处理文件 `myfirst.cpp` 时，它并没有得到指示要求用特定实参实例化文件中包含的模板定义。

#### 9.1.2    头文件中的模板

前面问题的通用解决方案是，用我们处理宏或内联函数的相同方法：在声明模板的头文件中包含模板的定义。

也就是说，不提供文件 `myfirst.cpp`，而是重写 `myfirst.hpp`，使其包含所有的模板声明*和*模板定义：

*basics/myfirst2.hpp*

```c++
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include <iostream>
#include <typeinfo>

// 模板的声明
template<typename T>
void printTypeof (T const&);

// 模板的实现/定义
template<typename T>
void printTypeof (T const& x)
{
    std::cout << typeid(x).name() << '\n';
}

#endif // MYFIRST_HPP
```

这种组织模板的方法叫做*包含模型*（inclusion model）。有了它，你就会发现我们的程序现在能正确编译、链接和执行了。

在这一点上，我们可以观察一下。最值得注意的是，这种方法极大地增加了包含头文件 `myfirst.hpp` 的开销。在这个例子中，开销不是模板定义本身大小导致的结果，而是我们还必须包含模板定义所使用的头文件这一事实带来的结果——在这种情况下，是 `<iostream>` 和 `<typeinfo>`。你可能会发现这相当于数万行代码，因为像 `<iostream>` 这样的头文件包含了许多自己的模板定义。

这在实践中是一个真正的问题，因为它大大增加了编译器编译重要程序所需的时间。因此，我们将研究一些可能的方法来解决这个问题，包括预编译头（见原书 141 页 9.3 节）和显式模板实例化（见原书 260 页 14.5 节）。

尽管存在这样的构建时间问题，我们还是建议尽量遵循包含模型来组织模板，直到有更好的机制可用。在 2017 年编写本书时，这样的机制已经在开发中了：*模块*（module）（在原书 366 页 17.11 节介绍）。这是一种语言机制，允许程序员以这样的方式更符合逻辑地组织代码：编译器可以单独编译所有声明，然后在需要时高效地、有选择地导入处理过的声明。

关于包含方法的另一个（更微妙的）注意是，非内联函数模板在一个重要方面与内联函数和宏不同：它们不会在调用点展开。相反，在它们被实例化时，会创建函数的一个新副本。因为这是一个自动过程，所以编译器最终可能会在两个不同的文件中创建两个副本，并且一些链接器可能在找到同一个函数的两个不同定义时报告错误。理论上，这不应该是我们关心的：这是 C++ 编译系统要容纳的问题。在实践中，这会在大多数时候运行良好，我们根本不需要处理这个问题。然而，对于创建自己的代码库的大型项目，问题偶尔会出现。第 14 章关于实例化机制的讨论和对 C++ 翻译系统（编译器）的仔细研究可能会帮助解决这些问题。

最后，我们需要指出，本例中适用于普通函数模板的内容也会适用于类模板成员函数和静态数据成员，也适用于成员函数模板。